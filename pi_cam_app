#!/usr/bin/python

import time
import sys
import yaml
import logging
from traceback import format_exception
from threading import Thread
from picamera import PiCamera
from flask_cors import CORS
from flask import request, jsonify, Flask # package for the webapp

camera = PiCamera()
app = Flask(__name__)
photo_effects = [ 'none', 'negative', 'solarize', 'sketch', 'denoise', 'emboss', 'oilpaint', 'hatch', 'gpen', 'pastel', 
  'watercolor', 'film', 'blur', 'saturation', 'colorswap', 'washedout', 'posterise', 'colorpoint', 
  'colorbalance', 'cartoon', 'deinterlace1', 'deinterlace2' ]
HOME_DIR = "/home/pi/"
IMAGES_DIR = HOME_DIR + "Pictures/"
VIDEO_DIR = HOME_DIR + "Videos/"
STOPMOTION_DIR = HOME_DIR + "stopmotion/"
APP_DIR = HOME_DIR + "brain-hat-button-controller/"
CONFIG_FILE = APP_DIR + "conf/application.yaml"
pi_cam_app_settings = {}

def init_logging():
  logging_logger = logging.getLogger(__name__)
  logging_logger.setLevel(logging.DEBUG)
  logging_logger.propagate = False
  # create console handler and set level to info
  handler = logging.StreamHandler()
  handler.setLevel(logging.DEBUG)
  formatter = logging.Formatter("%(asctime)s [pi_cam_app] [%(levelname)-5.5s]  %(message)s")
  handler.setFormatter(formatter)
  logging_logger.addHandler(handler)
  return logging_logger

def setup():
  global pi_cam_app_settings
  config_file = read_config_file()
  # read config dict's into more specific variables
  pi_cam_app_settings = {k: v for k, v in config_file['pi_cam_app'].items()}

def init_web_app():
  web_app_ip = pi_cam_app_settings['ip']
  web_app_port = pi_cam_app_settings['port']
  CORS(app)
  app.config["DEBUG"] = True
  logger.info("Starting pi_cam_app on ip:port --> " + web_app_ip + ':' + str(web_app_port))
  app.run(host=web_app_ip, port=int(web_app_port), use_reloader=False)

def read_config_file():
  # read config yaml file into dictionaries
  config_file = None
  with open(CONFIG_FILE, 'r') as ymlfile:
    config_file = yaml.full_load(ymlfile)
  return config_file

@app.route('/')
def hello():
  return 'Hello, from pi_cam_app!'

@app.route('/pi_cam_preview/<action>', methods=['GET'])
def pi_cam_preview_request(action):
  return handle_pi_cam_preview_request(action)

@app.route('/is_previewing', methods=['GET'])
def is_previewing_request():
  return handle_is_previewing_request()

@app.route('/take_photo/<filename>', methods=['GET'])
def take_photo_request(filename):
  message = handle_take_photo_request(filename)
  logger.info(message)
  return message

@app.route('/photo_effect_next/<current_effect>/<direction>', methods=['GET'])
def next_photo_effect(current_effect, direction):
  message = handle_next_effect_request(current_effect, direction)
  logger.info(message)
  return message

@app.route('/help', methods=['GET'])
def help_request():
  message = "This is the help message."
  logger.info(message)
  return jsonify(display_message=message)

@app.errorhandler(404)
def page_not_found(e):
  logger.error("404: The resource could not be found.")
  return jsonify(display_message="Error.")

def handle_is_previewing_request():
  preview = camera.previewing
  message = "Camera in preview: {0}".format(preview)
  logger.info(message)
  return str(preview)

def handle_pi_cam_preview_request(action):
  global camera
  if action == "start":
    if camera.closed:
      camera = PiCamera()
    camera.start_preview()
    msg = "Started pi cam preview."
  else:
    camera.stop_preview()
    camera.close()
    msg = "Stopped and closed pi cam preview."
  logger.info(msg)
  return msg

def handle_take_photo_request(filename):
  filepath = "{0}{1}".format(IMAGES_DIR, filename)
  try:
    change_res_and_shoot(filepath)
    message = "{0} written successfully!".format(filepath)
  except:
    exc_type, exc_value, exc_tb = sys.exc_info()
    exception_handler(exc_type, exc_value, exc_tb)
    message = "{0} not successfully written!".format(filepath)
  return message

def change_res_and_shoot(filepath):
  original_fps = camera.framerate
  set_resolution(4056, 3040, 5)
  camera.capture(filepath)
  set_resolution(480, 480, original_fps)

def set_resolution(x, y, fps):
  camera.stop_preview()
  camera.resolution = (x, y)
  camera.framerate = fps
  time.sleep(3)
  camera.start_preview()

def handle_next_effect_request(current_effect, direction):
  if direction in ['left', 'right']:
    return go_to_next_effect(current_effect, direction)
  else:
    logger.warning("No action taken for invalid direction: " + direction)

def go_to_next_effect(current_effect, dir):
  current_effect_ind = photo_effects.index(current_effect)
  if dir == 'left':
    if current_effect_ind == 0:
      next_effect = photo_effects[len(photo_effects) - 1]
    else:
      next_effect = photo_effects[current_effect_ind - 1]
  else:
    if current_effect_ind == len(photo_effects) - 1:
      next_effect = photo_effects[0]
    else:
      next_effect = photo_effects[current_effect_ind + 1]
  current_effect = next_effect
  set_photo_effect(next_effect)
  msg = next_effect
  logger.info("Changed effect to the next one to the " + dir + ", " + msg)
  return msg

def set_photo_effect(effect):
  camera.image_effect = effect
  x = Thread(target=set_image_text, args=('set_image_text', 3, effect))
  x.start()

def set_image_text(thread_name, wait_seconds, effect_name):
  logger.info("Thread \'{0}\': starting".format(thread_name))
  camera.annotate_text = "Effect: {0}".format(effect_name)
  time.sleep(wait_seconds)
  camera.annotate_text = ''
  logger.info("Thread \'{0}\': finishing".format(thread_name))

def exception_handler(exc_type, exc_value, exc_tb):
  err_str = str(format_exception(exc_type, exc_value, exc_tb))
  error_log = "An exception was encountered: " + err_str
  logger.error(error_log)

if __name__ == '__main__':
  global logger
  logger = init_logging()
  setup()
  init_web_app()
  while True:
    time.sleep(0.01)
